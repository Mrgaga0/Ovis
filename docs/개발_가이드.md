 // 01. 프로젝트 설정 가이드
// --------------------------------------------------------
// 다음 명령어를 순서대로 실행하여 프로젝트 설정

/*
# 1. Next.js 프로젝트 생성
npx create-next-app@latest ovis --typescript

# 선택 옵션
√ Would you like to use ESLint? Yes
√ Would you like to use Tailwind CSS? Yes
√ Would you like to use `src/` directory? Yes
√ Would you like to use App Router? (recommended) Yes
√ Would you like to customize the default import alias (@/*)? Yes
√ What import alias would you like configured? @/*

# 2. 필요한 패키지 설치
cd ovis
npm install electron electron-builder electron-serve
npm install shadcn-ui @google/generative-ai
npm install papaparse axios dotenv

# 3. shadcn/ui 설정
npx shadcn-ui@latest init

# 선택 옵션
√ Would you like to use TypeScript (recommended)? Yes
√ Which style would you like to use? Default
√ Which color would you like to use as base color? Slate
√ Where is your global CSS file? src/app/globals.css
√ Would you like to use CSS variables for colors? Yes
√ Are you using a custom tailwind prefix? No
√ Where is your tailwind.config.js located? tailwind.config.js
√ Configure the import alias for components: @/components
√ Configure the import alias for utils: @/lib/utils
√ Are you using React Server Components? Yes
√ Write configuration to components.json Yes
*/

// 02. Electron 설정
// --------------------------------------------------------
// electron-next.js 설정 (루트 디렉토리에 main 폴더 생성 후 main.js 파일 생성)

// main/main.js
const { app, BrowserWindow, ipcMain } = require('electron');
const serve = require('electron-serve');
const path = require('path');
const fs = require('fs');
require('dotenv').config();

const isProd = process.env.NODE_ENV === 'production';
const loadURL = isProd ? serve({ directory: 'out' }) : null;

let mainWindow;

function createMainWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    // 모바일 앱 스타일을 위한 프레임 제거 및 둥근 모서리
    frame: false,
    titleBarStyle: 'hidden',
    transparent: true,
    roundedCorners: true,
  });

  if (isProd) {
    loadURL(mainWindow);
  } else {
    mainWindow.loadURL('http://localhost:3000');
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on('closed', () => {
    mainWindow = null;
  });
}

app.whenReady().then(() => {
  createMainWindow();

  // 아카이브 디렉토리 확인 및 생성
  const archivePath = 'H:\\#2_Ai\\ovis아카이브2';
  const directories = [
    'articles/standard',
    'articles/mz',
    'youtube',
    'research',
    'data/rss',
    'data/search',
    'data/youtube',
    'workflows'
  ];

  if (!fs.existsSync(archivePath)) {
    fs.mkdirSync(archivePath, { recursive: true });
  }

  directories.forEach(dir => {
    const fullPath = path.join(archivePath, dir);
    if (!fs.existsSync(fullPath)) {
      fs.mkdirSync(fullPath, { recursive: true });
    }
  });

  // API 키 초기화 확인
  checkApiKeys();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (mainWindow === null) {
    createMainWindow();
  }
});

// API 키 확인 함수
function checkApiKeys() {
  const requiredKeys = ['GEMINI_API_KEY', 'BRAVE_SEARCH_API_KEY', 'YOUTUBE_API_KEY'];
  const missingKeys = requiredKeys.filter(key => !process.env[key]);
  
  if (missingKeys.length > 0) {
    console.log(`Missing API keys: ${missingKeys.join(', ')}`);
    // API 키 설정 화면으로 이동하는 로직 추가 필요
  }
}

// Gemini API 호출 처리
ipcMain.handle('call-gemini-api', async (event, { prompt, context }) => {
  try {
    // 외부 모듈로 분리 예정
    const response = await callGeminiAPI(prompt, context);
    return { success: true, data: response };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// 파일 시스템 작업 처리
ipcMain.handle('archive-content', async (event, { type, version, content, metadata }) => {
  try {
    const archivePath = 'H:\\#2_Ai\\ovis아카이브2';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const id = `${type}-${timestamp}`;
    
    // 메타데이터 저장 경로 설정
    let contentPath;
    if (type === 'article') {
      contentPath = path.join(archivePath, 'articles', version || 'standard', `${id}.md`);
    } else if (type === 'youtube') {
      contentPath = path.join(archivePath, 'youtube', `${id}.md`);
    } else {
      contentPath = path.join(archivePath, 'research', `${id}.md`);
    }
    
    // 콘텐츠 저장
    fs.writeFileSync(contentPath, content);
    
    // 메타데이터 저장
    const metadataObj = {
      id,
      type,
      version,
      createdAt: new Date().toISOString(),
      ...metadata,
      filePath: contentPath.replace(archivePath, '')
    };
    
    const metadataPath = contentPath + '.json';
    fs.writeFileSync(metadataPath, JSON.stringify(metadataObj, null, 2));
    
    return { success: true, id, path: contentPath };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// 03. 프리로드 스크립트
// --------------------------------------------------------
// main/preload.js
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  callGeminiAPI: (prompt, context) => ipcRenderer.invoke('call-gemini-api', { prompt, context }),
  archiveContent: (type, version, content, metadata) => ipcRenderer.invoke('archive-content', { type, version, content, metadata }),
  getArchivedContent: (type, filters) => ipcRenderer.invoke('get-archived-content', { type, filters }),
  minimizeWindow: () => ipcRenderer.send('minimize-window'),
  maximizeWindow: () => ipcRenderer.send('maximize-window'),
  closeWindow: () => ipcRenderer.send('close-window')
});

// 04. Next.js 구성 파일
// --------------------------------------------------------
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  // Electron에서 실행할 때 출력 디렉토리 설정
  output: process.env.NODE_ENV === 'production' ? 'export' : undefined,
  distDir: 'out',
  // 정적 자산 설정
  images: {
    unoptimized: true,
  }
};

module.exports = nextConfig;

// 05. 기본 레이아웃 및 UI 컴포넌트
// --------------------------------------------------------
// src/components/layout/AppShell.tsx
import React from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Bell, X, Minus, Maximize2 } from 'lucide-react';

interface AppShellProps {
  children: React.ReactNode;
}

export default function AppShell({ children }: AppShellProps) {
  // 윈도우 컨트롤 함수들
  const minimizeWindow = () => {
    if (window.electronAPI) {
      window.electronAPI.minimizeWindow();
    }
  };

  const maximizeWindow = () => {
    if (window.electronAPI) {
      window.electronAPI.maximizeWindow();
    }
  };

  const closeWindow = () => {
    if (window.electronAPI) {
      window.electronAPI.closeWindow();
    }
  };

  return (
    <div className="flex h-screen w-screen overflow-hidden bg-gradient-to-br from-slate-900 to-slate-800">
      {/* 커스텀 타이틀바 */}
      <div className="w-full flex items-center justify-between bg-slate-800 px-4 py-2 drag">
        <div className="text-white font-bold text-lg">Ovis</div>
        <div className="flex items-center space-x-2 no-drag">
          <Button 
            variant="ghost" 
            size="icon" 
            className="h-6 w-6 text-slate-400 hover:text-white hover:bg-slate-700 rounded-full"
            onClick={minimizeWindow}
          >
            <Minus className="h-4 w-4" />
          </Button>
          <Button 
            variant="ghost" 
            size="icon" 
            className="h-6 w-6 text-slate-400 hover:text-white hover:bg-slate-700 rounded-full"
            onClick={maximizeWindow}
          >
            <Maximize2 className="h-4 w-4" />
          </Button>
          <Button 
            variant="ghost" 
            size="icon" 
            className="h-6 w-6 text-slate-400 hover:text-white hover:bg-slate-700 rounded-full"
            onClick={closeWindow}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* 앱 사이드바 */}
      <div className="flex">
        <div className="w-16 bg-slate-800 flex flex-col items-center py-4 space-y-6">
          {/* 사이드바 아이콘들 */}
          {/* 여기에 각 기능별 아이콘 버튼 추가 */}
        </div>

        {/* 메인 콘텐츠 영역 */}
        <div className="flex-1 overflow-y-auto p-4">
          <Card className="w-full h-full bg-white/5 backdrop-blur-sm rounded-xl border-slate-700 shadow-xl">
            <div className="p-4 h-full">
              {children}
            </div>
          </Card>
        </div>
      </div>
    </div>
  );
}

// 06. 메인 대시보드 페이지
// --------------------------------------------------------
// src/app/page.tsx
'use client';

import { useEffect, useState } from 'react';
import AppShell from '@/components/layout/AppShell';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Newspaper, Youtube, LineChart, Clock, Settings } from 'lucide-react';

export default function Home() {
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    // API 연결 상태 확인
    checkConnection();
  }, []);

  const checkConnection = async () => {
    // 실제로는 Gemini API 연결 상태를 확인
    // 여기서는 간단히 API 키 존재 여부만 체크하는 것으로 가정
    setTimeout(() => {
      setIsConnected(true);
    }, 1500);
  };

  return (
    <AppShell>
      <div className="flex flex-col h-full">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h1 className="text-3xl font-bold text-white">Ovis Dashboard</h1>
            <p className="text-slate-400">AI-powered personal agent ecosystem</p>
          </div>
          <div className="flex items-center space-x-2">
            <div className={`h-3 w-3 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`}></div>
            <span className="text-sm text-slate-400">
              {isConnected ? 'Connected to Gemini' : 'Connecting...'}
            </span>
          </div>
        </div>

        {/* 기능 카드 그리드 */}
        <div className="grid grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
          {/* 기사 크롤링 */}
          <Card className="bg-gradient-to-br from-blue-900/30 to-blue-700/10 border-blue-700/30 hover:border-blue-500/50 transition-all duration-300 cursor-pointer overflow-hidden group">
            <CardHeader className="pb-2">
              <CardTitle className="flex items-center gap-2 text-blue-300">
                <Newspaper className="h-5 w-5" />
                <span>기사 크롤링</span>
              </CardTitle>
              <CardDescription className="text-blue-200/60">
                RSS에서 최신 뉴스 수집
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button className="w-full mt-2 bg-blue-600/20 text-blue-200 hover:bg-blue-600/40 border border-blue-700/30 group-hover:border-blue-500 transition-all duration-300">
                시작하기
              </Button>
            </CardContent>
          </Card>

          {/* 기사 작성 (일반) */}
          <Card className="bg-gradient-to-br from-purple-900/30 to-purple-700/10 border-purple-700/30 hover:border-purple-500/50 transition-all duration-300 cursor-pointer overflow-hidden group">
            <CardHeader className="pb-2">
              <CardTitle className="flex items-center gap-2 text-purple-300">
                <Newspaper className="h-5 w-5" />
                <span>기사 작성 (일반)</span>
              </CardTitle>
              <CardDescription className="text-purple-200/60">
                표준 뉴스 기사 생성
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button className="w-full mt-2 bg-purple-600/20 text-purple-200 hover:bg-purple-600/40 border border-purple-700/30 group-hover:border-purple-500 transition-all duration-300">
                시작하기
              </Button>
            </CardContent>
          </Card>

          {/* 기사 작성 (MZ) */}
          <Card className="bg-gradient-to-br from-pink-900/30 to-pink-700/10 border-pink-700/30 hover:border-pink-500/50 transition-all duration-300 cursor-pointer overflow-hidden group">
            <CardHeader className="pb-2">
              <CardTitle className="flex items-center gap-2 text-pink-300">
                <Newspaper className="h-5 w-5" />
                <span>기사 작성 (MZ)</span>
              </CardTitle>
              <CardDescription className="text-pink-200/60">
                MZ세대를 위한 기사 생성
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button className="w-full mt-2 bg-pink-600/20 text-pink-200 hover:bg-pink-600/40 border border-pink-700/30 group-hover:border-pink-500 transition-all duration-300">
                시작하기
              </Button>
            </CardContent>
          </Card>

          {/* YouTube 스크립트 */}
          <Card className="bg-gradient-to-br from-red-900/30 to-red-700/10 border-red-700/30 hover:border-red-500/50 transition-all duration-300 cursor-pointer overflow-hidden group">
            <CardHeader className="pb-2">
              <CardTitle className="flex items-center gap-2 text-red-300">
                <Youtube className="h-5 w-5" />
                <span>YouTube 스크립트</span>
              </CardTitle>
              <CardDescription className="text-red-200/60">
                YouTube 영상용 스크립트 생성
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button className="w-full mt-2 bg-red-600/20 text-red-200 hover:bg-red-600/40 border border-red-700/30 group-hover:border-red-500 transition-all duration-300">
                시작하기
              </Button>
            </CardContent>
          </Card>

          {/* 자동화 설정 */}
          <Card className="bg-gradient-to-br from-amber-900/30 to-amber-700/10 border-amber-700/30 hover:border-amber-500/50 transition-all duration-300 cursor-pointer overflow-hidden group">
            <CardHeader className="pb-2">
              <CardTitle className="flex items-center gap-2 text-amber-300">
                <Clock className="h-5 w-5" />
                <span>자동화 설정</span>
              </CardTitle>
              <CardDescription className="text-amber-200/60">
                워크플로우 자동화 구성
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button className="w-full mt-2 bg-amber-600/20 text-amber-200 hover:bg-amber-600/40 border border-amber-700/30 group-hover:border-amber-500 transition-all duration-300">
                시작하기
              </Button>
            </CardContent>
          </Card>

          {/* 분석 및 통계 */}
          <Card className="bg-gradient-to-br from-emerald-900/30 to-emerald-700/10 border-emerald-700/30 hover:border-emerald-500/50 transition-all duration-300 cursor-pointer overflow-hidden group">
            <CardHeader className="pb-2">
              <CardTitle className="flex items-center gap-2 text-emerald-300">
                <LineChart className="h-5 w-5" />
                <span>분석 및 통계</span>
              </CardTitle>
              <CardDescription className="text-emerald-200/60">
                콘텐츠 성과 및 추세 분석
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Button className="w-full mt-2 bg-emerald-600/20 text-emerald-200 hover:bg-emerald-600/40 border border-emerald-700/30 group-hover:border-emerald-500 transition-all duration-300">
                시작하기
              </Button>
            </CardContent>
          </Card>
        </div>

        {/* 최근 활동 및 상태 */}
        <Card className="flex-1 bg-slate-800/50 border-slate-700/50">
          <CardHeader>
            <CardTitle>최근 활동</CardTitle>
            <CardDescription>시스템 활동 및 생성된 콘텐츠</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="text-center text-slate-500 py-8">
              아직 활동 내역이 없습니다.
            </div>
          </CardContent>
        </Card>
      </div>
    </AppShell>
  );
}

// 07. 기사 크롤링 페이지
// --------------------------------------------------------
// src/app/article-crawler/page.tsx
'use client';

import { useState } from 'react';
import AppShell from '@/components/layout/AppShell';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Checkbox } from '@/components/ui/checkbox';

export default function ArticleCrawler() {
  const [rssUrls, setRssUrls] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  const [crawledData, setCrawledData] = useState([]);

  const handleRssUrlChange = (e) => {
    setRssUrls(e.target.value);
  };

  const startCrawling = async () => {
    if (!rssUrls.trim()) return;

    setIsProcessing(true);
    
    try {
      // 실제로는 Electron IPC를 통해 백엔드에 요청
      // 여기서는 간단한 예시로 대체
      const urls = rssUrls.split('\n').filter(url => url.trim());
      
      // 임시 데이터 생성 (실제로는 실제 크롤링 결과를 사용)
      setTimeout(() => {
        const mockResults = urls.map((url, index) => ({
          id: `article-${index}`,
          source: url,
          title: `샘플 기사 제목 ${index + 1}`,
          date: new Date().toISOString(),
          summary: '이것은 자동으로 생성된 샘플 요약입니다...',
          selected: false
        }));
        
        setCrawledData(mockResults);
        setIsProcessing(false);
      }, 2000);
    } catch (error) {
      console.error('크롤링 에러:', error);
      setIsProcessing(false);
    }
  };

  const toggleSelection = (id) => {
    setCrawledData(crawledData.map(item => 
      item.id === id ? { ...item, selected: !item.selected } : item
    ));
  };

  const generateArticles = () => {
    const selectedItems = crawledData.filter(item => item.selected);
    // 실제로는 선택된 항목들을 기반으로 기사 생성 로직 구현
    console.log('선택된 항목으로 기사 생성:', selectedItems);
  };

  return (
    <AppShell>
      <div className="flex flex-col h-full">
        <div className="mb-6">
          <h1 className="text-3xl font-bold text-white">기사 크롤링</h1>
          <p className="text-slate-400">RSS 피드에서 최신 뉴스를 수집합니다</p>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 flex-1">
          {/* 입력 영역 */}
          <Card className="bg-slate-800/50 border-slate-700/50 lg:col-span-1">
            <CardHeader>
              <CardTitle>RSS 피드 입력</CardTitle>
              <CardDescription>크롤링할 RSS 피드 URL을 입력하세요</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="rss-urls">RSS 피드 URL (한 줄에 하나씩)</Label>
                  <textarea
                    id="rss-urls"
                    className="w-full min-h-[200px] p-2 bg-slate-900 text-slate-200 border border-slate-700 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="https://example.com/rss"
                    value={rssUrls}
                    onChange={handleRssUrlChange}
                  />
                </div>

                <Button 
                  className="w-full bg-blue-600 hover:bg-blue-700 text-white"
                  onClick={startCrawling}
                  disabled={isProcessing}
                >
                  {isProcessing ? '처리 중...' : '크롤링 시작'}
                </Button>
              </div>
            </CardContent>
          </Card>

          {/* 결과 영역 */}
          <Card className="bg-slate-800/50 border-slate-700/50 lg:col-span-2">
            <CardHeader>
              <CardTitle>수집된 기사</CardTitle>
              <CardDescription>크롤링된 기사 목록</CardDescription>
            </CardHeader>
            <CardContent>
              {isProcessing ? (
                <div className="flex justify-center items-center py-10">
                  <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-blue-500"></div>
                </div>
              ) : crawledData.length > 0 ? (
                <div className="space-y-4">
                  <div className="flex justify-between mb-4">
                    <span className="text-sm text-slate-400">{crawledData.length}개의 기사가 발견됨</span>
                    <Button 
                      size="sm" 
                      variant="outline"
                      onClick={generateArticles}
                      disabled={!crawledData.some(item => item.selected)}
                    >
                      선택된 기사로 콘텐츠 생성
                    </Button>
                  </div>
                  
                  <div className="space-y-2 max-h-[400px] overflow-y-auto">
                    {crawledData.map((item) => (
                      <div key={item.id} className="flex items-start gap-3 p-3 bg-slate-700/30 rounded-lg hover:bg-slate-700/50 transition-colors">
                        <Checkbox 
                          id={item.id} 
                          checked={item.selected}
                          onCheckedChange={() => toggleSelection(item.id)}
                        />
                        <div>
                          <h3 className="font-medium text-white">{item.title}</h3>
                          <p className="text-sm text-slate-400 mt-1">{item.summary}</p>
                          <div className="flex items-center gap-2 mt-2">
                            <span className="text-xs text-slate-500">{new Date(item.date).toLocaleString()}</span>
                            <span className="text-xs bg-slate-700 px-2 py-0.5 rounded-full">{item.source}</span>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              ) : (
                <div className="text-center text-slate-500 py-10">
                  크롤링을 시작하면 여기에 결과가 표시됩니다.
                </div>
              )}
            </CardContent>
          </Card>
        </div>
      </div>
    </AppShell>
  );
}

// 08. 기사 생성 (일반) 페이지
// --------------------------------------------------------
// src/app/article-generator/page.tsx
'use client';

import { useState } from 'react';
import AppShell from '@/components/layout/AppShell';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';

export default function ArticleGenerator() {
  const [articleTitle, setArticleTitle] = useState('');
  const [keywords, setKeywords] = useState('');
  const [articleType, setArticleType] = useState('standard');
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedContent, setGeneratedContent] = useState('');

  const handleTitleChange = (e) => {
    setArticleTitle(e.target.value);
  };

  const handleKeywordsChange = (e) => {
    setKeywords(e.target.value);
  };

  const generateArticle = async () => {
    if (!articleTitle.trim()) return;
    
    setIsGenerating(true);
    
    try {
      // 실제로는 Electron IPC를 통해 Gemini API에 요청
      // 예시 프롬프트
      const prompt = `
        주제: ${articleTitle}
        키워드: ${keywords || '없음'}
        유형: ${articleType === 'standard' ? '일반 뉴스 기사' : 'MZ세대를 위한 뉴스 기사'}
        
        위 주제와 키워드로 뉴스 기사를 작성해주세요. 실제 뉴스 기사처럼 제목, 소제목, 도입부, 본문, 결론을 포함해야 합니다.
        ${articleType === 'mz' ? 'MZ세대를 위한 기사이므로 쉽고 간결한 문체, 트렌디한 표현, 공감대 형성 문구를 사용해주세요.' : ''}
      `;
      
      // 임시 예시 데이터 (실제로는 Gemini API 응답)
      setTimeout(() => {
        const mockArticle = `# ${articleTitle}

## 최신 동향을 살펴보다

최근 ${articleTitle}에 관한 이슈가 주목받고 있습니다. 전문가들은 이번 사태가 앞으로의 추세에 큰 영향을 미칠 것으로 전망하고 있습니다.

## 주요 내용

${keywords.split(',').map(keyword => `- ${keyword.trim()}: 관련 내용이 여기에 표시됩니다.`).join('\n')}

## 전문가의 견해

전문가 A씨는 "이번 일은 앞으로의 방향성을 결정짓는 중요한 사안"이라며 신중한 접근이 필요하다고 강조했습니다.

## 향후 전망

앞으로의 진행 상황에 많은 이들의 관심이 쏠리고 있으며, 후속 조치가 어떻게 이루어질지 귀추가 주목됩니다.`;
        
        setGeneratedContent(mockArticle);
        setIsGenerating(false);
      }, 3000);
    } catch (error) {
      console.error('기사 생성 에러:', error);
      setIsGenerating(false);
    }
  };

  const saveArticle = () => {
    // 실제로는 Electron IPC를 통해 파일 시스템에 저장
    if (window.electronAPI) {
      window.electronAPI.archiveContent('article', articleType, generatedContent, {
        title: articleTitle,
        keywords: keywords.split(',').map(k => k.trim()),
        type: articleType
      }).then(result => {
        if (result.success) {
          alert('기사가 저장되었습니다.');
        } else {
          alert('저장 중 오류가 발생했습니다: ' + result.error);
        }
      });
    }
  };

  return (
    <AppShell>
      <div className="flex flex-col h-full">
        <div className="mb-6">
          <h1 className="text-3xl font-bold text-white">기사 작성</h1>
          <p className="text-slate-400">AI를 활용한 뉴스 기사 작성</p>
        </div>

        <Tabs defaultValue="standard" className="flex-1">
          <TabsList className="grid w-full grid-cols-2 mb-6">
            <TabsTrigger value="standard" onClick={() => setArticleType('standard')}>일반 기사</TabsTrigger>
            <TabsTrigger value="mz" onClick={() => setArticleType('mz')}>MZ세대 기사</TabsTrigger>
          </TabsList>
          
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 h-[calc(100%-50px)]">
            {/* 입력 영역 */}
            <Card className="bg-slate-800/50 border-slate-700/50">
              <CardHeader>
                <CardTitle>기사 정보 입력</CardTitle>
                <CardDescription>생성할 기사의 정보를 입력하세요</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="article-title">기사 제목</Label>
                    <Input 
                      id="article-title" 
                      placeholder="기사 제목을 입력하세요"
                      value={articleTitle}
                      onChange={handleTitleChange}
                    />
                  </div>
                  
                  <div className="space-y-2">
                    <Label htmlFor="keywords">키워드 (쉼표로 구분)</Label>
                    <Input 
                      id="keywords" 
                      placeholder="주요 키워드를 입력하세요"
                      value={keywords}
                      onChange={handleKeywordsChange}
                    />
                  </div>
                  
                  <div className="space-y-2">
                    <Label htmlFor="article-style">기사 스타일</Label>
                    <Select value={articleType} onValueChange={setArticleType}>
                      <SelectTrigger id="article-style">
                        <SelectValue placeholder="스타일 선택" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="standard">일반 뉴스 스타일</SelectItem>
                        <SelectItem value="mz">MZ세대 친화적 스타일</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>

                  <Button 
                    className="w-full bg-purple-600 hover:bg-purple-700 text-white"
                    onClick={generateArticle}
                    disabled={isGenerating || !articleTitle.trim()}
                  >
                    {isGenerating ? '생성 중...' : '기사 생성'}
                  </Button>
                </div>
              </CardContent>
            </Card>

            {/* 결과 영역 */}
            <Card className="bg-slate-800/50 border-slate-700/50">
              <CardHeader className="flex flex-row items-center justify-between">
                <div>
                  <CardTitle>생성된 기사</CardTitle>
                  <CardDescription>AI가 생성한 기사 내용</CardDescription>
                </div>
                {generatedContent && (
                  <Button 
                    variant="outline"
                    onClick={saveArticle}
                  >
                    저장하기
                  </Button>
                )}
              </CardHeader>
              <CardContent>
                {isGenerating ? (
                  <div className="flex justify-center items-center py-10">
                    <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-purple-500"></div>
                  </div>
                ) : generatedContent ? (
                  <div className="prose prose-invert prose-sm max-w-none">
                    <div dangerouslySetInnerHTML={{ 
                      __html: generatedContent.replace(/\n/g, '<br />').replace(/## (.*)/g, '<h2>$1</h2>').replace(/# (.*)/g, '<h1>$1</h1>') 
                    }} />
                  </div>
                ) : (
                  <div className="text-center text-slate-500 py-10">
                    기사를 생성하면 여기에 결과가 표시됩니다.
                  </div>
                )}
              </CardContent>
            </Card>
          </div>
        </Tabs>
      </div>
    </AppShell>
  );
}

// 09. YouTube 스크립트 생성 페이지
// --------------------------------------------------------
// src/app/youtube-script/page.tsx
'use client';

import { useState } from 'react';
import AppShell from '@/components/layout/AppShell';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Slider } from '@/components/ui/slider';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Textarea } from '@/components/ui/textarea';

export default function YoutubeScript() {
  const [videoTitle, setVideoTitle] = useState('');
  const [videoTopic, setVideoTopic] = useState('');
  const [videoDuration, setVideoDuration] = useState(10); // 분 단위
  const [targetAudience, setTargetAudience] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedScript, setGeneratedScript] = useState('');
  const [activeTab, setActiveTab] = useState('input');

  const handleTitleChange = (e) => {
    setVideoTitle(e.target.value);
  };

  const handleTopicChange = (e) => {
    setVideoTopic(e.target.value);
  };

  const handleAudienceChange = (e) => {
    setTargetAudience(e.target.value);
  };

  const handleDurationChange = (value) => {
    setVideoDuration(value[0]);
  };

  const generateScript = async () => {
    if (!videoTitle.trim() || !videoTopic.trim()) return;
    
    setIsGenerating(true);
    setActiveTab('preview');
    
    try {
      // 실제로는 Electron IPC를 통해 Gemini API에 요청
      // 예시 프롬프트
      const prompt = `
        제목: ${videoTitle}
        주제: ${videoTopic}
        영상 길이: ${videoDuration}분
        대상 시청자: ${targetAudience || '일반 대중'}
        
        위 정보를 바탕으로 유튜브 영상 스크립트를 작성해주세요. 다음을 포함해야 합니다:
        1. 인트로 (10-15초)
        2. 주제 소개 및 핵심 내용
        3. 세부 내용 설명 (${videoDuration}분에 맞게 조절)
        4. 결론 및 아웃트로
        5. 콜투액션 (구독, 좋아요 유도)
        
        각 섹션마다 [인트로], [주제 소개], [세부 내용], [결론], [아웃트로] 등의 마크업을 사용하고,
        가능하다면 화면에 표시할 시각적 요소나 자막에 대한 제안도 함께 제공해주세요.
      `;
      
      // 임시 예시 데이터 (실제로는 Gemini API 응답)
      setTimeout(() => {
        const mockScript = `# ${videoTitle}

## 영상 길이: ${videoDuration}분

### [인트로] (0:00 - 0:15)
안녕하세요 여러분! 오늘은 ${videoTopic}에 대해 알아보는 시간을 가져보겠습니다. 이 영상을 통해 여러분은 [주요 이점 3가지]를 배우실 수 있을 거예요. 시작해볼까요?

### [주제 소개] (0:15 - 1:30)
${videoTopic}은 최근 많은 관심을 받고 있는 주제입니다. 특히 [관련 최신 트렌드나 통계]에 따르면, 이 분야는 앞으로 더욱 중요해질 전망입니다.

**화면 표시:** ${videoTopic} 관련 이미지와 주요 통계 그래픽

### [세부 내용 1] (1:30 - 3:30)
먼저 살펴볼 내용은 [첫 번째 주요 포인트]입니다. 이것은 [설명과 예시]로 이해할 수 있습니다.

**화면 표시:** 설명을 뒷받침하는 시각 자료, 다이어그램 또는 예시 이미지

### [세부 내용 2] (3:30 - 5:30)
두 번째로 중요한 점은 [두 번째 주요 포인트]입니다. 이것이 중요한 이유는 [근거와 이유]입니다.

**화면 표시:** 비교 차트 또는 관련 실제 예시 영상

### [세부 내용 3] (5:30 - 7:30)
마지막으로 살펴볼 내용은 [세 번째 주요 포인트]입니다. 이는 [설명과 예시]를 통해 더 잘 이해할 수 있습니다.

**화면 표시:** 단계별 프로세스 또는 시연 영상

### [결론] (7:30 - 9:30)
지금까지 우리는 ${videoTopic}에 대한 [주요 포인트 요약]을 살펴봤습니다. 이러한 정보가 여러분께 [어떤 도움이 될지]에 대해 생각해보시기 바랍니다.

**화면 표시:** 주요 포인트를 정리한 불릿 포인트 리스트

### [아웃트로] (9:30 - 10:00)
오늘 영상이 도움이 되셨다면 좋아요와 구독 부탁드립니다! 다음 영상에서는 [관련 주제 제안]에 대해 다룰 예정이니 알림 설정도 해주세요! 댓글로 여러분의 의견도 남겨주세요. 시청해주셔서 감사합니다!

**화면 표시:** 채널 로고, 구독 버튼 및 다음 영상 미리보기`;
        
        setGeneratedScript(mockScript);
        setIsGenerating(false);
      }, 3000);
    } catch (error) {
      console.error('스크립트 생성 에러:', error);
      setIsGenerating(false);
    }
  };

  const saveScript = () => {
    // 실제로는 Electron IPC를 통해 파일 시스템에 저장
    if (window.electronAPI) {
      window.electronAPI.archiveContent('youtube', null, generatedScript, {
        title: videoTitle,
        topic: videoTopic,
        duration: videoDuration,
        targetAudience
      }).then(result => {
        if (result.success) {
          alert('스크립트가 저장되었습니다.');
        } else {
          alert('저장 중 오류가 발생했습니다: ' + result.error);
        }
      });
    }
  };

  return (
    <AppShell>
      <div className="flex flex-col h-full">
        <div className="mb-6">
          <h1 className="text-3xl font-bold text-white">YouTube 스크립트</h1>
          <p className="text-slate-400">AI를 활용한 유튜브 영상 스크립트 생성</p>
        </div>

        <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1">
          <TabsList className="grid w-full grid-cols-2 mb-6">
            <TabsTrigger value="input">입력 정보</TabsTrigger>
            <TabsTrigger value="preview">스크립트 미리보기</TabsTrigger>
          </TabsList>
          
          <TabsContent value="input" className="flex-1">
            <Card className="bg-slate-800/50 border-slate-700/50 h-full">
              <CardHeader>
                <CardTitle>영상 정보 입력</CardTitle>
                <CardDescription>스크립트 생성에 필요한 정보를 입력하세요</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="video-title">영상 제목</Label>
                    <Input 
                      id="video-title" 
                      placeholder="영상 제목을 입력하세요"
                      value={videoTitle}
                      onChange={handleTitleChange}
                    />
                  </div>
                  
                  <div className="space-y-2">
                    <Label htmlFor="video-topic">영상 주제</Label>
                    <Textarea 
                      id="video-topic" 
                      placeholder="영상에서 다룰 주제를 자세히 설명해주세요"
                      className="min-h-[100px]"
                      value={videoTopic}
                      onChange={handleTopicChange}
                    />
                  </div>
                  
                  <div className="space-y-4">
                    <div className="flex justify-between">
                      <Label htmlFor="video-duration">영상 길이 (분)</Label>
                      <span className="text-sm text-slate-400">{videoDuration}분</span>
                    </div>
                    <Slider
                      id="video-duration"
                      min={5}
                      max={30}
                      step={1}
                      value={[videoDuration]}
                      onValueChange={handleDurationChange}
                    />
                  </div>
                  
                  <div className="space-y-2">
                    <Label htmlFor="target-audience">대상 시청자</Label>
                    <Input 
                      id="target-audience" 
                      placeholder="예: 초보자, 전문가, 10대, 직장인 등"
                      value={targetAudience}
                      onChange={handleAudienceChange}
                    />
                  </div>

                  <Button 
                    className="w-full bg-red-600 hover:bg-red-700 text-white mt-4"
                    onClick={generateScript}
                    disabled={isGenerating || !videoTitle.trim() || !videoTopic.trim()}
                  >
                    {isGenerating ? '생성 중...' : '스크립트 생성'}
                  </Button>
                </div>
              </CardContent>
            </Card>
          </TabsContent>
          
          <TabsContent value="preview" className="flex-1">
            <Card className="bg-slate-800/50 border-slate-700/50 h-full">
              <CardHeader className="flex flex-row items-center justify-between">
                <div>
                  <CardTitle>생성된 스크립트</CardTitle>
                  <CardDescription>AI가 생성한 영상 스크립트</CardDescription>
                </div>
                {generatedScript && (
                  <Button 
                    variant="outline"
                    onClick={saveScript}
                  >
                    저장하기
                  </Button>
                )}
              </CardHeader>
              <CardContent>
                {isGenerating ? (
                  <div className="flex justify-center items-center py-10">
                    <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-red-500"></div>
                  </div>
                ) : generatedScript ? (
                  <div className="prose prose-invert prose-sm max-w-none max-h-[500px] overflow-y-auto">
                    <div dangerouslySetInnerHTML={{ 
                      __html: generatedScript
                        .replace(/\n/g, '<br />')
                        .replace(/### \[(.*?)\] \((.*?)\)/g, '<h3><span class="text-yellow-400">[$1]</span> <span class="text-slate-400">($2)</span></h3>')
                        .replace(/## (.*)/g, '<h2>$1</h2>')
                        .replace(/# (.*)/g, '<h1>$1</h1>')
                        .replace(/\*\*화면 표시:\*\* (.*)/g, '<div class="bg-slate-700/50 p-2 rounded my-2 border-l-4 border-yellow-500"><strong>화면 표시:</strong> $1</div>')
                    }} />
                  </div>
                ) : (
                  <div className="text-center text-slate-500 py-10">
                    스크립트를 생성하면 여기에 결과가 표시됩니다.
                  </div>
                )}
              </CardContent>
            </Card>
          </TabsContent>
        </Tabs>
      </div>
    </AppShell>
  );
}

// 10. 자동화 설정 페이지
// --------------------------------------------------------
// src/app/automation/page.tsx
'use client';

import { useState } from 'react';
import AppShell from '@/components/layout/AppShell';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Plus, X, Clock, ArrowRight } from 'lucide-react';

export default function Automation() {
  const [workflows, setWorkflows] = useState([
    {
      id: 'workflow-1',
      name: '일일 뉴스 수집',
      description: '매일 오전 8시에 뉴스 수집 및 기사 생성',
      isActive: true,
      schedule: '매일 오전 8:00',
      steps: [
        { id: 'step-1', name: 'RSS 피드 수집', type: 'crawler', config: { sources: ['https://example.com/rss'] } },
        { id: 'step-2', name: '주요 토픽 추출', type: 'processor', config: {} },
        { id: 'step-3', name: '기사 생성 (일반)', type: 'generator', config: { version: 'standard' } }
      ]
    },
    {
      id: 'workflow-2',
      name: '주간 YouTube 콘텐츠',
      description: '매주 월요일에 YouTube 스크립트 생성',
      isActive: false,
      schedule: '매주 월요일 오전 10:00',
      steps: [
        { id: 'step-1', name: '트렌드 분석', type: 'research', config: {} },
        { id: 'step-2', name: '주제 추천', type: 'processor', config: {} },
        { id: 'step-3', name: '스크립트 생성', type: 'youtube', config: { duration: 10 } }
      ]
    }
  ]);
  
  const [isCreating, setIsCreating] = useState(false);
  const [newWorkflow, setNewWorkflow] = useState({
    name: '',
    description: '',
    schedule: 'daily',
    time: '08:00',
    steps: []
  });

  const toggleWorkflowStatus = (workflowId) => {
    setWorkflows(workflows.map(workflow => 
      workflow.id === workflowId ? { ...workflow, isActive: !workflow.isActive } : workflow
    ));
  };

  const addStep = () => {
    setNewWorkflow({
      ...newWorkflow,
      steps: [
        ...newWorkflow.steps,
        { id: `new-step-${newWorkflow.steps.length + 1}`, name: '', type: 'crawler', config: {} }
      ]
    });
  };

  const removeStep = (stepIndex) => {
    setNewWorkflow({
      ...newWorkflow,
      steps: newWorkflow.steps.filter((_, index) => index !== stepIndex)
    });
  };

  const updateStepName = (index, name) => {
    setNewWorkflow({
      ...newWorkflow,
      steps: newWorkflow.steps.map((step, i) => 
        i === index ? { ...step, name } : step
      )
    });
  };

  const updateStepType = (index, type) => {
    setNewWorkflow({
      ...newWorkflow,
      steps: newWorkflow.steps.map((step, i) => 
        i === index ? { ...step, type, config: {} } : step
      )
    });
  };

  const startCreatingWorkflow = () => {
    setIsCreating(true);
    setNewWorkflow({
      name: '',
      description: '',
      schedule: 'daily',
      time: '08:00',
      steps: []
    });
  };

  const cancelCreatingWorkflow = () => {
    setIsCreating(false);
  };

  const saveNewWorkflow = () => {
    const workflow = {
      id: `workflow-${workflows.length + 1}`,
      name: newWorkflow.name,
      description: newWorkflow.description,
      isActive: true,
      schedule: `${newWorkflow.schedule === 'daily' ? '매일' : '매주 월요일'} ${newWorkflow.time}`,
      steps: newWorkflow.steps
    };
    
    setWorkflows([...workflows, workflow]);
    setIsCreating(false);
  };

  return (
    <AppShell>
      <div className="flex flex-col h-full">
        <div className="flex justify-between items-center mb-6">
          <div>
            <h1 className="text-3xl font-bold text-white">자동화 설정</h1>
            <p className="text-slate-400">워크플로우 자동화 구성 및 관리</p>
          </div>
          {!isCreating && (
            <Button 
              className="bg-amber-600 hover:bg-amber-700 text-white"
              onClick={startCreatingWorkflow}
            >
              <Plus className="w-4 h-4 mr-2" /> 새 워크플로우
            </Button>
          )}
        </div>

        {isCreating ? (
          <Card className="bg-slate-800/50 border-slate-700/50 mb-4">
            <CardHeader>
              <CardTitle>새 워크플로우 생성</CardTitle>
              <CardDescription>자동화할 새 워크플로우를 구성하세요</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="workflow-name">워크플로우 이름</Label>
                  <Input 
                    id="workflow-name" 
                    placeholder="예: 일일 뉴스 수집"
                    value={newWorkflow.name}
                    onChange={(e) => setNewWorkflow({ ...newWorkflow, name: e.target.value })}
                  />
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="workflow-desc">설명</Label>
                  <Input 
                    id="workflow-desc" 
                    placeholder="워크플로우에 대한 설명을 입력하세요"
                    value={newWorkflow.description}
                    onChange={(e) => setNewWorkflow({ ...newWorkflow, description: e.target.value })}
                  />
                </div>
                
                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="schedule-type">실행 주기</Label>
                    <Select 
                      value={newWorkflow.schedule} 
                      onValueChange={(val) => setNewWorkflow({ ...newWorkflow, schedule: val })}
                    >
                      <SelectTrigger id="schedule-type">
                        <SelectValue placeholder="실행 주기 선택" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="daily">매일</SelectItem>
                        <SelectItem value="weekly">매주 월요일</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  
                  <div className="space-y-2">
                    <Label htmlFor="schedule-time">실행 시간</Label>
                    <Input 
                      id="schedule-time" 
                      type="time"
                      value={newWorkflow.time}
                      onChange={(e) => setNewWorkflow({ ...newWorkflow, time: e.target.value })}
                    />
                  </div>
                </div>
                
                <div className="pt-4">
                  <div className="flex justify-between items-center mb-4">
                    <h3 className="text-lg font-semibold text-white">워크플로우 단계</h3>
                    <Button variant="outline" size="sm" onClick={addStep}>
                      <Plus className="w-4 h-4 mr-1" /> 단계 추가
                    </Button>
                  </div>
                  
                  {newWorkflow.steps.length === 0 ? (
                    <div className="text-center text-slate-500 py-8 border border-dashed border-slate-700 rounded-lg">
                      워크플로우 단계를 추가하세요
                    </div>
                  ) : (
                    <div className="space-y-3">
                      {newWorkflow.steps.map((step, index) => (
                        <div key={step.id} className="flex items-center gap-2 p-3 bg-slate-700/30 rounded-lg group">
                          <div className="flex-1 grid grid-cols-5 gap-2">
                            <div className="col-span-3">
                              <Input 
                                placeholder="단계 이름"
                                value={step.name}
                                onChange={(e) => updateStepName(index, e.target.value)}
                              />
                            </div>
                            <div className="col-span-2">
                              <Select 
                                value={step.type} 
                                onValueChange={(val) => updateStepType(index, val)}
                              >
                                <SelectTrigger>
                                  <SelectValue placeholder="단계 유형" />
                                </SelectTrigger>
                                <SelectContent>
                                  <SelectItem value="crawler">RSS 수집</SelectItem>
                                  <SelectItem value="processor">데이터 처리</SelectItem>
                                  <SelectItem value="generator">기사 생성</SelectItem>
                                  <SelectItem value="youtube">YouTube 스크립트</SelectItem>
                                  <SelectItem value="research">연구 및 분석</SelectItem>
                                </SelectContent>
                              </Select>
                            </div>
                          </div>
                          
                          <Button 
                            variant="ghost" 
                            size="icon"
                            className="opacity-0 group-hover:opacity-100 transition-opacity"
                            onClick={() => removeStep(index)}
                          >
                            <X className="w-4 h-4 text-slate-400" />
                          </Button>
                          
                          {index < newWorkflow.steps.length - 1 && (
                            <div className="absolute left-1/2 transform -translate-x-1/2 mt-16">
                              <ArrowRight className="w-4 h-4 text-slate-500 rotate-90" />
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
                
                <div className="flex justify-end space-x-2 pt-4">
                  <Button variant="outline" onClick={cancelCreatingWorkflow}>
                    취소
                  </Button>
                  <Button 
                    className="bg-amber-600 hover:bg-amber-700 text-white"
                    onClick={saveNewWorkflow}
                    disabled={!newWorkflow.name || newWorkflow.steps.length === 0}
                  >
                    저장
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ) : null}

        <div className="grid grid-cols-1 gap-4">
          {workflows.map((workflow) => (
            <Card key={workflow.id} className={`border-l-4 ${workflow.isActive ? 'border-l-green-500' : 'border-l-slate-600'} bg-slate-800/50 border-slate-700/50`}>
              <CardHeader className="flex flex-row items-start justify-between">
                <div>
                  <CardTitle>{workflow.name}</CardTitle>
                  <CardDescription>{workflow.description}</CardDescription>
                  <div className="flex items-center mt-2">
                    <Clock className="w-4 h-4 text-slate-400 mr-1" />
                    <span className="text-xs text-slate-400">{workflow.schedule}</span>
                  </div>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="text-sm text-slate-400">{workflow.isActive ? '활성' : '비활성'}</span>
                  <Switch
                    checked={workflow.isActive}
                    onCheckedChange={() => toggleWorkflowStatus(workflow.id)}
                  />
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-2">
                  <h3 className="text-sm font-medium text-slate-400">워크플로우 단계:</h3>
                  <div className="flex flex-wrap items-center gap-2">
                    {workflow.steps.map((step, index) => (
                      <div key={step.id} className="flex items-center">
                        <div className="bg-slate-700 px-3 py-1 rounded-full text-xs">
                          {step.name}
                        </div>
                        {index < workflow.steps.length - 1 && (
                          <ArrowRight className="w-4 h-4 text-slate-500 mx-1" />
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    </AppShell>
  );
}

// 11. 핵심 AI 통합 모듈
// --------------------------------------------------------
// src/lib/ai/gemini-api.js
import { GoogleGenerativeAI } from '@google/generative-ai';

// API 키 가져오기 (실제로는 .env 또는 Electron의 환경 변수에서 가져옴)
// 개발 환경에서 임시로 사용하는 방식
let apiKey = process.env.GEMINI_API_KEY || '';
let modelName = process.env.GEMINI_MODEL || 'gemini-2.0-flash-thinking-exp-1219';

// 설정 함수
export const configureGeminiAPI = (key, model) => {
  apiKey = key;
  modelName = model || modelName;
};

// Gemini API 초기화
const initGeminiAPI = () => {
  try {
    if (!apiKey) {
      console.error('Gemini API 키가 설정되지 않았습니다.');
      return null;
    }
    
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: modelName });
    return model;
  } catch (error) {
    console.error('Gemini API 초기화 오류:', error);
    return null;
  }
};

// 프롬프트 실행 함수
export const runGeminiPrompt = async (prompt, options = {}) => {
  try {
    const model = initGeminiAPI();
    if (!model) {
      throw new Error('Gemini API가 초기화되지 않았습니다.');
    }
    
    const generationConfig = {
      temperature: options.temperature || 0.7,
      maxOutputTokens: options.maxOutputTokens || 8192,
      topK: options.topK || 40,
      topP: options.topP || 0.95,
    };
    
    const result = await model.generateContent({
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      generationConfig,
    });
    
    return result.response.text();
  } catch (error) {
    console.error('Gemini API 오류:', error);
    throw error;
  }
};

// 에이전트별 최적화된 프롬프트 템플릿
export const promptTemplates = {
  // 뉴스 기사 생성 (일반)
  standardArticle: `
    당신은 전문적인 뉴스 기사 작성 AI입니다. 다음 정보를 바탕으로 형식과 내용을 갖춘 뉴스 기사를 작성해주세요.
    
    주제: {{title}}
    키워드: {{keywords}}
    
    다음 사항을 반드시 포함해야 합니다:
    1. 명확하고 간결한 헤드라인
    2. 첫 문단에 핵심 정보 요약 (5W1H)
    3. 관련 배경 정보와 맥락
    4. 관련 당사자들의 견해 (있는 경우)
    5. 향후 전망 또는 영향
    
    기사는 객관적이고 중립적인 톤으로 작성하며, 사실 기반의 정보를 제공해야 합니다.
  `,
  
  // 뉴스 기사 생성 (MZ)
  mzArticle: `
    당신은 MZ세대(밀레니얼+Z세대)를 위한 뉴스 기사 작성 AI입니다. 다음 정보를 바탕으로 형식과 내용을 갖춘 뉴스 기사를 작성해주세요.
    
    주제: {{title}}
    키워드: {{keywords}}
    
    다음 사항을 반드시 포함해야 합니다:
    1. 주목을 끄는 간결한 헤드라인 (약간의 재미있는 요소 포함)
    2. 첫 문단에 핵심 정보 요약 (친근한 톤으로)
    3. 관련 배경 정보와 맥락 (쉽게 이해할 수 있는 비유 사용)
    4. MZ세대와 관련된 영향이나 관점
    5. 짧은 문단과 직관적인 설명
    
    기사는 다음과 같은 MZ세대 특성을 반영해야 합니다:
    - 간결하고 직관적인 언어 사용
    - 이모티콘이나 인터넷 용어 적절히 활용
    - 공감대를 형성하는 문체
    - 중요 정보는 굵게 강조
    - "TL;DR" 요약 제공
  `,
  
  // YouTube 스크립트 생성
  youtubeScript: `
    당신은 전문적인 YouTube 스크립트 작성 AI입니다. 다음 정보를 바탕으로 영상 스크립트를 작성해주세요.
    
    제목: {{title}}
    주제: {{topic}}
    영상 길이: {{duration}}분
    대상 시청자: {{audience}}
    
    다음 구조로 스크립트를 작성해주세요:
    1. [인트로] (0:00 - 0:15) - 시청자의 관심을 끄는 짧은 소개
    2. [주제 소개] (0:15 - 약 1분) - 주제 개요와 영상에서 다룰 내용
    3. [세부 내용] (나머지 시간을 적절히 분배) - 주요 포인트별로 섹션 구분
    4. [결론] (마지막 1분) - 핵심 내용 요약 및 시청자에게 가치 제공
    5. [아웃트로] (마지막 30초) - 구독, 좋아요 등 콜투액션
    
    각 섹션마다 [섹션명] (타임스탬프)와 같은 형식으로 표시해주세요.
    시각적 요소나 화면 지시사항은 **화면 표시:** 형식으로 추가해주세요.
    
    스크립트는 다음 특성을 갖추어야 합니다:
    - 대화체로 작성 (구어체)
    - 간결하고 이해하기 쉬운 문장
    - 시청자와 상호작용하는 질문이나 호기심 유발 요소 포함
    - 영상 길이({{duration}}분)에 맞게 내용 분량 조절
  `,
  
  // RSS 피드 분석 및 주제 추출
  rssAnalysis: `
    당신은 뉴스 RSS 피드 분석 전문 AI입니다. 다음 RSS 피드 내용을 분석하고 주요 주제와 트렌드를 추출해주세요.
    
    RSS 피드 내용:
    {{content}}
    
    다음 정보를 추출해주세요:
    1. 주요 주제 5개 (중요도 순)
    2. 각 주제별 관련 키워드
    3. 주제별 감정 분석 (긍정/중립/부정)
    4. 트렌드 식별 (핫 토픽, 상승 중인 주제)
    5. 추가 조사가 필요한 주제 제안
    
    결과는 구조화된 형식으로 제공해주세요.
  `
};

// 12. RSS 크롤러 모듈
// --------------------------------------------------------
// src/lib/data/rss-crawler.js
import axios from 'axios';
import { parseString } from 'xml2js';
import { promisify } from 'util';
import { runGeminiPrompt, promptTemplates } from '../ai/gemini-api';

const parseXml = promisify(parseString);

// RSS 피드 가져오기
export const fetchRssFeed = async (url) => {
  try {
    const response = await axios.get(url);
    const result = await parseXml(response.data);
    return result;
  } catch (error) {
    console.error(`RSS 피드 가져오기 오류 (${url}):`, error);
    throw error;
  }
};

// RSS 피드 내용을 구조화된 데이터로 변환
export const processRssFeed = (feedData) => {
  try {
    // RSS 데이터 구조에 따라 처리 로직을 조정해야 함
    // 여기서는 일반적인 RSS 형식을 가정
    const channel = feedData.rss.channel[0];
    const feedTitle = channel.title[0];
    const feedDescription = channel.description[0];
    
    const items = channel.item.map(item => ({
      title: item.title[0],
      link: item.link[0],
      pubDate: item.pubDate ? item.pubDate[0] : '',
      description: item.description ? item.description[0] : '',
      content: item['content:encoded'] ? item['content:encoded'][0] : '',
      categories: item.category ? item.category.map(cat => cat.trim()) : []
    }));
    
    return {
      feedTitle,
      feedDescription,
      items
    };
  } catch (error) {
    console.error('RSS 피드 처리 오류:', error);
    throw error;
  }
};

// 여러 RSS 피드 크롤링 및 통합
export const crawlMultipleFeeds = async (urls) => {
  try {
    const feedPromises = urls.map(url => fetchRssFeed(url));
    const feedResults = await Promise.allSettled(feedPromises);
    
    // 성공적으로 가져온 피드만 처리
    const successfulFeeds = feedResults
      .filter(result => result.status === 'fulfilled')
      .map((result, index) => ({
        url: urls[index],
        data: processRssFeed(result.value)
      }));
    
    // 실패한 피드 로깅
    feedResults
      .filter(result => result.status === 'rejected')
      .forEach((result, index) => {
        console.error(`RSS 피드 가져오기 실패 (${urls[index]}):`, result.reason);
      });
    
    return successfulFeeds;
  } catch (error) {
    console.error('여러 RSS 피드 크롤링 오류:', error);
    throw error;
  }
};

// RSS 피드에서 주제 추출
export const extractTopicsFromFeeds = async (feeds) => {
  try {
    // 모든 피드 항목을 하나의 문자열로 결합
    const allContent = feeds.flatMap(feed => 
      feed.data.items.map(item => 
        `제목: ${item.title}\n설명: ${item.description || '없음'}\n카테고리: ${item.categories.join(', ') || '없음'}\n\n`
      )
    ).join('\n');
    
    // Gemini API를 사용하여 주제 추출
    const prompt = promptTemplates.rssAnalysis.replace('{{content}}', allContent);
    const analysis = await runGeminiPrompt(prompt);
    
    return analysis;
  } catch (error) {
    console.error('RSS 피드 주제 추출 오류:', error);
    throw error;
  }
};

// 13. 파일 시스템 아카이브 모듈
// --------------------------------------------------------
// src/lib/data/archive-manager.js
// Electron 환경에서 실행될 때 window.electronAPI가 사용 가능함
// 브라우저 환경에서는 로컬 스토리지를 사용하는 대체 로직 필요

// 아카이브 항목 저장 (Electron API 또는 로컬 스토리지 사용)
export const saveContent = async (type, version, content, metadata) => {
  if (window.electronAPI) {
    // Electron 환경: IPC를 통해 메인 프로세스에 요청
    return await window.electronAPI.archiveContent(type, version, content, metadata);
  } else {
    // 브라우저 환경: 로컬 스토리지 사용
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const id = `${type}-${timestamp}`;
      
      const metadataObj = {
        id,
        type,
        version,
        createdAt: new Date().toISOString(),
        ...metadata,
      };
      
      // 콘텐츠와 메타데이터 저장
      localStorage.setItem(`ovis-content-${id}`, content);
      localStorage.setItem(`ovis-metadata-${id}`, JSON.stringify(metadataObj));
      
      // 인덱스 업데이트
      const indexKey = 'ovis-content-index';
      const existingIndex = JSON.parse(localStorage.getItem(indexKey) || '[]');
      existingIndex.push(id);
      localStorage.setItem(indexKey, JSON.stringify(existingIndex));
      
      return { success: true, id };
    } catch (error) {
      console.error('로컬 스토리지 저장 오류:', error);
      return { success: false, error: error.message };
    }
  }
};

// 아카이브 항목 가져오기
export const getContent = async (id) => {
  if (window.electronAPI) {
    // Electron 환경: IPC를 통해 메인 프로세스에 요청
    return await window.electronAPI.getArchivedContent(id);
  } else {
    // 브라우저 환경: 로컬 스토리지 사용
    try {
      const content = localStorage.getItem(`ovis-content-${id}`);
      const metadataStr = localStorage.getItem(`ovis-metadata-${id}`);
      
      if (!content || !metadataStr) {
        throw new Error('콘텐츠를 찾을 수 없습니다.');
      }
      
      const metadata = JSON.parse(metadataStr);
      
      return { 
        success: true, 
        data: { 
          id, 
          content, 
          metadata 
        } 
      };
    } catch (error) {
      console.error('로컬 스토리지 가져오기 오류:', error);
      return { success: false, error: error.message };
    }
  }
};

// 모든 아카이브 항목 목록 가져오기
export const getAllContents = async (type = null, filters = {}) => {
  if (window.electronAPI) {
    // Electron 환경: IPC를 통해 메인 프로세스에 요청
    return await window.electronAPI.getArchivedContents(type, filters);
  } else {
    // 브라우저 환경: 로컬 스토리지 사용
    try {
      const indexKey = 'ovis-content-index';
      const allIds = JSON.parse(localStorage.getItem(indexKey) || '[]');
      
      // 메타데이터 가져오기
      const contents = [];
      for (const id of allIds) {
        const metadataStr = localStorage.getItem(`ovis-metadata-${id}`);
        if (metadataStr) {
          const metadata = JSON.parse(metadataStr);
          
          // 타입 필터 적용
          if (type && metadata.type !== type) {
            continue;
          }
          
          // 추가 필터 적용
          let matchesFilters = true;
          for (const [key, value] of Object.entries(filters)) {
            if (metadata[key] !== value) {
              matchesFilters = false;
              break;
            }
          }
          
          if (matchesFilters) {
            contents.push({
              id,
              metadata,
              // 콘텐츠는 크기가 클 수 있으므로 메타데이터만 먼저 로드
            });
          }
        }
      }
      
      return { success: true, data: contents };
    } catch (error) {
      console.error('로컬 스토리지 목록 가져오기 오류:', error);
      return { success: false, error: error.message };
    }
  }
};

// 14. 워크플로우 자동화 엔진
// --------------------------------------------------------
// src/lib/automation/workflow-engine.js
// 워크플로우 실행을 위한 기본 엔진

// 워크플로우 저장소
const workflows = {};

// 워크플로우 등록
export const registerWorkflow = (id, config) => {
  workflows[id] = {
    ...config,
    status: 'idle', // idle, running, completed, failed
    lastRun: null,
    nextRun: null,
    logs: []
  };
  
  // 스케줄이 있으면 다음 실행 시간 계산
  if (config.schedule) {
    scheduleNextRun(id);
  }
  
  return id;
};

// 워크플로우 비활성화
export const disableWorkflow = (id) => {
  if (workflows[id]) {
    workflows[id].enabled = false;
  }
};

// 워크플로우 활성화
export const enableWorkflow = (id) => {
  if (workflows[id]) {
    workflows[id].enabled = true;
    scheduleNextRun(id);
  }
};

// 다음 실행 시간 계산
const scheduleNextRun = (id) => {
  const workflow = workflows[id];
  if (!workflow || !workflow.enabled) return;
  
  let nextRun = null;
  
  // 스케줄 문자열 파싱 (간단한 구현)
  if (workflow.schedule.includes('매일')) {
    // 매일 실행
    const timeMatch = workflow.schedule.match(/(\d+):(\d+)/);
    if (timeMatch) {
      const hours = parseInt(timeMatch[1]);
      const minutes = parseInt(timeMatch[2]);
      
      nextRun = new Date();
      nextRun.setHours(hours, minutes, 0, 0);
      
      // 이미 지난 시간이면 다음 날로 설정
      if (nextRun <= new Date()) {
        nextRun.setDate(nextRun.getDate() + 1);
      }
    }
  } else if (workflow.schedule.includes('매주 월요일')) {
    // 매주 월요일 실행
    const timeMatch = workflow.schedule.match(/(\d+):(\d+)/);
    if (timeMatch) {
      const hours = parseInt(timeMatch[1]);
      const minutes = parseInt(timeMatch[2]);
      
      nextRun = new Date();
      nextRun.setHours(hours, minutes, 0, 0);
      
      // 현재 요일 가져오기 (0: 일요일, 1: 월요일, ...)
      const currentDay = nextRun.getDay();
      
      // 다음 월요일까지의 일수 계산
      const daysUntilMonday = currentDay === 1 ? 
        (nextRun <= new Date() ? 7 : 0) : // 오늘이 월요일이지만 시간이 지났으면 다음 주 월요일
        (1 - currentDay + 7) % 7; // 다음 월요일까지의 일수
      
      nextRun.setDate(nextRun.getDate() + daysUntilMonday);
    }
  }
  
  if (nextRun) {
    workflow.nextRun = nextRun;
    
    // 실제 타이머 설정 (Electron 환경에서는 다른 방식으로 구현 필요)
    const delay = nextRun.getTime() - new Date().getTime();
    setTimeout(() => {
      executeWorkflow(id);
    }, delay);
  }
};

// 워크플로우 실행
export const executeWorkflow = async (id) => {
  const workflow = workflows[id];
  if (!workflow) {
    console.error(`워크플로우를 찾을 수 없음: ${id}`);
    return { success: false, error: '워크플로우를 찾을 수 없습니다.' };
  }
  
  // 이미 실행 중이면 중단
  if (workflow.status === 'running') {
    return { success: false, error: '워크플로우가 이미 실행 중입니다.' };
  }
  
  // 상태 업데이트
  workflow.status = 'running';
  workflow.lastRun = new Date();
  workflow.logs = [];
  
  try {
    // 각 단계 실행
    let stepResults = {};
    
    for (const step of workflow.steps) {
      try {
        workflow.logs.push(`[${new Date().toISOString()}] 단계 시작: ${step.name}`);
        
        // 단계 유형에 따라 실행
        let result;
        switch (step.type) {
          case 'crawler':
            result = await executeCrawlerStep(step, stepResults);
            break;
          case 'processor':
            result = await executeProcessorStep(step, stepResults);
            break;
          case 'generator':
            result = await executeGeneratorStep(step, stepResults);
            break;
          case 'youtube':
            result = await executeYoutubeStep(step, stepResults);
            break;
          case 'research':
            result = await executeResearchStep(step, stepResults);
            break;
          default:
            throw new Error(`알 수 없는 단계 유형: ${step.type}`);
        }
        
        // 결과 저장
        stepResults[step.id] = result;
        workflow.logs.push(`[${new Date().toISOString()}] 단계 완료: ${step.name}`);
      } catch (error) {
        workflow.logs.push(`[${new Date().toISOString()}] 단계 실패: ${step.name} - ${error.message}`);
        throw error; // 상위로 오류 전파
      }
    }
    
    // 완료 상태로 업데이트
    workflow.status = 'completed';
    workflow.logs.push(`[${new Date().toISOString()}] 워크플로우 완료`);
    
    // 다음 실행 일정 설정
    scheduleNextRun(id);
    
    return { success: true, results: stepResults };
  } catch (error) {
    // 실패 상태로 업데이트
    workflow.status = 'failed';
    workflow.logs.push(`[${new Date().toISOString()}] 워크플로우 실패: ${error.message}`);
    
    // 다음 실행 일정 설정 (실패해도 계속)
    scheduleNextRun(id);
    
    return { success: false, error: error.message };
  }
};

// 단계 실행 함수들 (각 단계 유형별로 구현 필요)
// 여기서는 간단한 구현만 제공

// RSS 크롤러 단계 실행
const executeCrawlerStep = async (step, previousResults) => {
  // 실제 구현에서는 src/lib/data/rss-crawler.js의 함수 사용
  // 예시 코드
  const urls = step.config.sources || [];
  
  // 크롤링 실행 (실제 구현 필요)
  // ...
  
  return {
    type: 'crawler',
    items: [
      { title: '샘플 기사 1', source: urls[0] || 'https://example.com' },
      { title: '샘플 기사 2', source: urls[0] || 'https://example.com' }
    ]
  };
};

// 프로세서 단계 실행
const executeProcessorStep = async (step, previousResults) => {
  // 이전 단계의 결과를 처리
  // ...
  
  return {
    type: 'processor',
    topics: ['주제 1', '주제 2', '주제 3'],
    keywords: ['키워드 1', '키워드 2', '키워드 3']
  };
};

// 기사 생성 단계 실행
const executeGeneratorStep = async (step, previousResults) => {
  // 실제 구현에서는 Gemini API를 사용한 기사 생성
  // ...
  
  const version = step.config.version || 'standard';
  
  return {
    type: 'generator',
    version,
    articles: [
      { 
        title: '샘플 생성 기사 1',
        content: '샘플 기사 내용...',
        keywords: ['키워드 1', '키워드 2']
      }
    ]
  };
};

// YouTube 스크립트 생성 단계 실행
const executeYoutubeStep = async (step, previousResults) => {
  // 실제 구현에서는 Gemini API를 사용한 스크립트 생성
  // ...
  
  return {
    type: 'youtube',
    scripts: [
      {
        title: '샘플 YouTube 스크립트',
        content: '샘플 스크립트 내용...',
        duration: step.config.duration || 10
      }
    ]
  };
};

// 연구 단계 실행
const executeResearchStep = async (step, previousResults) => {
  // 실제 구현에서는 추가 데이터 수집 및 분석
  // ...
  
  return {
    type: 'research',
    trends: ['트렌드 1', '트렌드 2', '트렌드 3'],
    insights: ['인사이트 1', '인사이트 2']
  };
};

// 워크플로우 목록 가져오기
export const getWorkflows = () => {
  return Object.entries(workflows).map(([id, workflow]) => ({
    id,
    name: workflow.name,
    description: workflow.description,
    status: workflow.status,
    enabled: workflow.enabled,
    lastRun: workflow.lastRun,
    nextRun: workflow.nextRun,
    schedule: workflow.schedule,
    stepsCount: workflow.steps.length
  }));
};

// 워크플로우 상세 정보 가져오기
export const getWorkflowDetails = (id) => {
  const workflow = workflows[id];
  if (!workflow) return null;
  
  return {
    id,
    ...workflow
  };
};

// 15. 설정 및 환경 변수 관리 모듈
// --------------------------------------------------------
// src/lib/config/settings.js
import { useState, useEffect } from 'react';

// 기본 설정
const defaultSettings = {
  apiKeys: {
    gemini: '',
    brave: '',
    youtube: ''
  },
  archivePath: 'H:\\#2_Ai\\ovis아카이브2',
  geminiModel: 'gemini-2.0-flash-thinking-exp-1219',
  ui: {
    theme: 'dark',
    animations: true
  }
};

// 설정 저장 (Electron 또는 로컬 스토리지)
export const saveSettings = async (settings) => {
  if (window.electronAPI) {
    // Electron 환경
    return await window.electronAPI.saveSettings(settings);
  } else {
    // 브라우저 환경
    try {
      localStorage.setItem('ovis-settings', JSON.stringify(settings));
      return { success: true };
    } catch (error) {
      console.error('설정 저장 오류:', error);
      return { success: false, error: error.message };
    }
  }
};

// 설정 로드 (Electron 또는 로컬 스토리지)
export const loadSettings = async () => {
  if (window.electronAPI) {
    // Electron 환경
    const result = await window.electronAPI.getSettings();
    return result.success ? result.data : defaultSettings;
  } else {
    // 브라우저 환경
    try {
      const settings = localStorage.getItem('ovis-settings');
      return settings ? JSON.parse(settings) : defaultSettings;
    } catch (error) {
      console.error('설정 로드 오류:', error);
      return defaultSettings;
    }
  }
};

// React Hook을 사용한 설정 관리
export const useSettings = () => {
  const [settings, setSettings] = useState(defaultSettings);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // 컴포넌트 마운트 시 설정 로드
    const fetchSettings = async () => {
      const loadedSettings = await loadSettings();
      setSettings(loadedSettings);
      setLoading(false);
    };
    
    fetchSettings();
  }, []);
  
  // 설정 업데이트 함수
  const updateSettings = async (newSettings) => {
    const updatedSettings = { ...settings, ...newSettings };
    const result = await saveSettings(updatedSettings);
    
    if (result.success) {
      setSettings(updatedSettings);
    }
    
    return result;
  };
  
  // API 키 업데이트 함수
  const updateApiKey = async (keyName, value) => {
    const updatedApiKeys = { ...settings.apiKeys, [keyName]: value };
    return await updateSettings({ apiKeys: updatedApiKeys });
  };
  
  return {
    settings,
    loading,
    updateSettings,
    updateApiKey
  };
};

// 16. 빌드 및 패키지 구성 파일
// --------------------------------------------------------
// package.json
/*
{
  "name": "ovis",
  "version": "0.1.0",
  "private": true,
  "main": "main/main.js",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "electron:dev": "concurrently \"npm run dev\" \"electron .\"",
    "electron:build": "next build && electron-builder",
    "electron:package": "next build && next export && electron-builder"
  },
  "dependencies": {
    "@google/generative-ai": "^0.1.3",
    "@radix-ui/react-checkbox": "^1.0.4",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-slider": "^1.1.2",
    "@radix-ui/react-switch": "^1.0.3",
    "@radix-ui/react-tabs": "^1.0.4",
    "axios": "^1.6.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "dotenv": "^16.3.1",
    "electron-serve": "^1.2.0",
    "lucide-react": "^0.292.0",
    "next": "14.0.3",
    "papaparse": "^5.4.1",
    "react": "^18",
    "react-dom": "^18",
    "tailwind-merge": "^2.1.0",
    "tailwindcss-animate": "^1.0.7",
    "xml2js": "^0.6.2"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.0.1",
    "concurrently": "^8.2.2",
    "electron": "^28.0.0",
    "electron-builder": "^24.6.4",
    "eslint": "^8",
    "eslint-config-next": "14.0.3",
    "postcss": "^8",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  },
  "build": {
    "appId": "com.ovis.app",
    "productName": "Ovis",
    "files": [
      "main",
      "out"
    ],
    "directories": {
      "buildResources": "resources",
      "output": "dist"
    },
    "win": {
      "target": "nsis",
      "icon": "resources/icon.ico"
    }
  }
}
*/

// 17. 실행 방법 및 개발 시작 가이드
// --------------------------------------------------------
/*
# 개발 환경 설정 및 실행 가이드

## 1. 프로젝트 구성

먼저 터미널에서 다음 명령어를 실행하여 Next.js 프로젝트를 생성합니다:

```bash
npx create-next-app@latest ovis --typescript
```

프롬프트에서 다음과 같이 선택합니다:
- ESLint: Yes
- Tailwind CSS: Yes
- src/ 디렉토리: Yes
- App Router: Yes
- 기본 import alias (@/*): Yes

## 2. 필요한 패키지 설치

프로젝트 디렉토리로 이동하여 필요한 패키지들을 설치합니다:

```bash
cd ovis
npm install electron electron-builder electron-serve
npm install shadcn-ui @google/generative-ai
npm install papaparse axios dotenv xml2js
```

## 3. shadcn/ui 설정

다음 명령어로 shadcn/ui를 초기화합니다:

```bash
npx shadcn-ui@latest init
```

선택 옵션:
- TypeScript: Yes
- 스타일: Default
- 기본 색상: Slate
- 글로벌 CSS 파일: src/app/globals.css
- CSS 변수: Yes
- 커스텀 prefix: No
- tailwind.config.js 위치: tailwind.config.js
- 컴포넌트 import alias: @/components
- 유틸리티 import alias: @/lib/utils
- React Server Components: Yes
- 설정 저장: Yes

## 4. 필요한 UI 컴포넌트 설치

다음 명령어로 필요한 UI 컴포넌트들을 설치합니다:

```bash
npx shadcn-ui@latest add button card input label tabs select checkbox switch slider
```

## 5. 프로젝트 구조 설정

제공된 코드 파일들을 다음과 같은 구조로 배치합니다:

```
ovis/
  ├── main/
  │   ├── main.js
  │   └── preload.js
  ├── src/
  │   ├── app/
  │   │   ├── page.tsx                    # 메인 대시보드
  │   │   ├── article-crawler/
  │   │   │   └── page.tsx                # 기사 크롤링 페이지
  │   │   ├── article-generator/
  │   │   │   └── page.tsx                # 기사 생성 페이지
  │   │   ├── youtube-script/
  │   │   │   └── page.tsx                # YouTube 스크립트 페이지 
  │   │   └── automation/
  │   │       └── page.tsx                # 자동화 설정 페이지
  │   ├── components/
  │   │   ├── ui/                         # shadcn/ui 컴포넌트
  │   │   └── layout/
  │   │       └── AppShell.tsx            # 앱 레이아웃 컴포넌트
  │   └── lib/
  │       ├── ai/
  │       │   └── gemini-api.js           # Gemini API 통합
  │       ├── data/
  │       │   ├── rss-crawler.js          # RSS 크롤러
  │       │   └── archive-manager.js      # 아카이브 관리
  │       ├── automation/
  │       │   └── workflow-engine.js      # 워크플로우 엔진
  │       └── config/
  │           └── settings.js             # 설정 관리
  ├── .env                                # 환경 변수 (API 키 등)
  ├── next.config.js
  └── package.json
```

## 6. 환경 변수 설정

루트 디렉토리에 `.env` 파일을 생성하고 API 키를 설정합니다:

```
GEMINI_API_KEY=your_gemini_api_key_here
BRAVE_SEARCH_API_KEY=your_brave_api_key_here
YOUTUBE_API_KEY=your_youtube_api_key_here
GEMINI_MODEL=gemini-2.0-flash-thinking-exp-1219
```

## 7. 개발 환경에서 실행

개발 환경에서 Electron + Next.js 앱을 실행하려면:

```bash
npm run electron:dev
```

## 8. 빌드 및 패키징

배포용 빌드를 생성하려면:

```bash
npm run electron:build
```

이 명령어는 `dist` 디렉토리에 설치 파일을 생성합니다.

## 9. 아카이브 디렉토리 설정

애플리케이션이 처음 실행될 때 `H:\#2_Ai\ovis아카이브2` 디렉토리가 자동으로 생성되며, 기사나 스크립트 등의 콘텐츠가 여기에 저장됩니다. 경로가 다른 경우 `main/main.js` 파일에서 `archivePath` 변수를 수정하세요.
*/